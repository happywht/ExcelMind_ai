# Phase 2 ä¼˜åŒ–å®æ–½è®¡åˆ’

**åˆ¶å®šæ—¥æœŸ**: 2026-01-25
**åŸºäºè¯„ä¼°**:
- FULLSTACK_INTEGRATION_ANALYSIS.md
- BACKEND_ARCHITECTURE_ANALYSIS.md
- CTO_STRATEGIC_ASSESSMENT_2026.md

**æ•´ä½“è¯„çº§**: A- (85/100)

---

## æ‰§è¡Œæ‘˜è¦

åŸºäºä¸‰ä»½æ·±åº¦è¯„ä¼°æŠ¥å‘Šçš„åˆ†æ,ExcelMind AIé¡¹ç›®åœ¨Sprint 1 Day 1-3å–å¾—äº†æ˜¾è‘—æˆæœ(å®Œæˆåº¦105%ã€æ•ˆç‡æå‡167%),ä½†ä¹Ÿæš´éœ²å‡ºä¸€äº›å…³é”®é—®é¢˜éœ€è¦ç«‹å³è§£å†³ã€‚æœ¬è®¡åˆ’å°†è¿™äº›é—®é¢˜æŒ‰ä¼˜å…ˆçº§æ’åº,å¹¶åˆ¶å®šè¯¦ç»†çš„å®æ–½æ–¹æ¡ˆã€‚

### ä¼˜åŒ–ä¼˜å…ˆçº§æ€»è§ˆ

| ä¼˜å…ˆçº§ | ä¼˜åŒ–é¡¹ | é¢„è®¡å·¥æœŸ | ROI | æˆªæ­¢æ—¶é—´ |
|--------|--------|----------|-----|----------|
| **P0-1** | APIå¯†é’¥å®‰å…¨åŠ å›º | 4å°æ—¶ | æé«˜ | Day 4 |
| **P0-2** | WebSocketå®ç°ç»Ÿä¸€ | 8å°æ—¶ | é«˜ | Day 5 |
| **P0-3** | é”™è¯¯å¤„ç†æ ‡å‡†åŒ– | 6å°æ—¶ | é«˜ | Day 6 |
| **P0-4** | å†…å­˜æ³„æ¼ä¿®å¤ | 8å°æ—¶ | é«˜ | Day 7 |
| **P1-1** | çŠ¶æ€ç®¡ç†ä¼˜åŒ– | 12å°æ—¶ | ä¸­é«˜ | Day 10 |
| **P1-2** | ç›‘æ§ä½“ç³»å®Œå–„ | 16å°æ—¶ | ä¸­é«˜ | Day 14 |
| **P1-3** | ä¾èµ–æ³¨å…¥å¼•å…¥ | 12å°æ—¶ | ä¸­ | Day 17 |
| **P1-4** | APIè®¤è¯æˆæƒ | 16å°æ—¶ | é«˜ | Day 21 |

---

## ç¬¬ä¸€éƒ¨åˆ†: P0çº§åˆ«ä¼˜åŒ– (ç«‹å³æ‰§è¡Œ)

### P0-1: APIå¯†é’¥å®‰å…¨åŠ å›º â±ï¸ 4å°æ—¶

**é—®é¢˜**: APIå¯†é’¥ç›´æ¥æš´éœ²åœ¨å‰ç«¯ä»£ç ä¸­(`services/zhipuService.ts`)

**é£é™©ç­‰çº§**: ğŸ”´ é«˜å±

#### å®æ–½æ–¹æ¡ˆ

**æ­¥éª¤1: åç«¯ä»£ç†API (2å°æ—¶)**

```typescript
// api/controllers/aiController.ts (æ–°å»º)
import { Request, Response } from 'express';
import { aiService } from '../../services/aiService';

export class AIController {
  async generateCode(req: Request, res: Response): Promise<void> {
    try {
      const { prompt, context, options } = req.body;

      // å‚æ•°éªŒè¯
      if (!prompt || typeof prompt !== 'string') {
        return res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_PROMPT',
            message: 'æç¤ºè¯æ ¼å¼é”™è¯¯'
          }
        });
      }

      if (prompt.length > 10000) {
        return res.status(400).json({
          success: false,
          error: {
            code: 'PROMPT_TOO_LONG',
            message: 'æç¤ºè¯é•¿åº¦è¶…è¿‡é™åˆ¶'
          }
        });
      }

      // é€Ÿç‡é™åˆ¶æ£€æŸ¥
      const clientId = req.headers['x-client-id'] as string;
      await rateLimiter.checkLimit(clientId, 'ai:generate');

      // è°ƒç”¨AIæœåŠ¡ (å¯†é’¥åœ¨æœåŠ¡å™¨ç¯å¢ƒå˜é‡)
      const result = await aiService.generateCode(prompt, context, options);

      res.json({
        success: true,
        data: result
      });

    } catch (error) {
      next(error);
    }
  }

  async generateDataProcessingCode(req: Request, res: Response): Promise<void> {
    try {
      const { prompt, context } = req.body;

      const result = await aiService.generateDataProcessingCode(prompt, context);

      res.json({
        success: true,
        data: result
      });

    } catch (error) {
      next(error);
    }
  }
}
```

**æ­¥éª¤2: è·¯ç”±é…ç½® (1å°æ—¶)**

```typescript
// api/routes/ai.ts (æ–°å»º)
import { Router } from 'express';
import { AIController } from '../controllers/aiController';
import { rateLimiter } from '../middleware/rateLimiter';

const router = Router();
const controller = new AIController();

// AIä»£ç†è·¯ç”±
router.post('/generate', rateLimiter, controller.generateCode);
router.post('/generate-data-code', rateLimiter, controller.generateDataProcessingCode);

export { router as aiRouter };
```

**æ­¥éª¤3: å‰ç«¯APIè°ƒç”¨ä¿®æ”¹ (1å°æ—¶)**

```typescript
// services/zhipuService.ts (ä¿®æ”¹)
export const generateDataProcessingCode = async (
  prompt: string,
  context: any[]
): Promise<AIProcessResult> => {
  // ä¿®æ”¹å‰: ç›´æ¥è°ƒç”¨AI (å¯†é’¥æš´éœ²)
  // const response = await client.messages.create({ ... });

  // ä¿®æ”¹å: é€šè¿‡åç«¯ä»£ç†
  const response = await fetch('/api/v2/ai/generate-data-code', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Client-ID': getClientId() // å®¢æˆ·ç«¯æ ‡è¯†
    },
    body: JSON.stringify({ prompt, context })
  });

  if (!response.ok) {
    throw new Error(`AIè°ƒç”¨å¤±è´¥: ${response.statusText}`);
  }

  const data = await response.json();
  return data.data;
};

// è¾…åŠ©å‡½æ•°
function getClientId(): string {
  let clientId = localStorage.getItem('client_id');
  if (!clientId) {
    clientId = `client_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    localStorage.setItem('client_id', clientId);
  }
  return clientId;
}
```

**æ­¥éª¤4: ç¯å¢ƒå˜é‡é…ç½® (0.5å°æ—¶)**

```bash
# .env (æœåŠ¡å™¨ç«¯)
ZHIPU_API_KEY=your-secret-key-here
AI_RATE_LIMIT=100
AI_RATE_WINDOW=60000
```

**æ­¥éª¤5: ç§»é™¤å‰ç«¯ä¾èµ– (0.5å°æ—¶)**

```json
// package.json
{
  "dependencies": {
    // ç§»é™¤æˆ–æ”¹ä¸º devDependencies
    "@anthropic-ai/sdk": "^0.27.3" // ä»…ä¿ç•™ç±»å‹å®šä¹‰
  }
}
```

#### éªŒæ”¶æ ‡å‡†

- âœ… å‰ç«¯ä»£ç ä¸­æ— APIå¯†é’¥
- âœ… æ‰€æœ‰AIè°ƒç”¨é€šè¿‡åç«¯ä»£ç†
- âœ… é€Ÿç‡é™åˆ¶æ­£å¸¸å·¥ä½œ
- âœ… é”™è¯¯å¤„ç†å®Œå–„

#### é¢„æœŸæ”¶ç›Š

- **å®‰å…¨æ€§æå‡**: 100% (å¯†é’¥å®Œå…¨ä¸æš´éœ²)
- **æˆæœ¬å¯æ§**: å¯åœ¨åç«¯æ·»åŠ é…é¢é™åˆ¶
- **å®¡è®¡èƒ½åŠ›**: å¯è®°å½•æ‰€æœ‰AIè°ƒç”¨

---

### P0-2: WebSocketå®ç°ç»Ÿä¸€ â±ï¸ 8å°æ—¶

**é—®é¢˜**: å­˜åœ¨ä¸¤å¥—WebSocketå®ç°(`WebSocketServer`å’Œ`WebSocketManager`)

**å½±å“**: ä»£ç é‡å¤ã€ç»´æŠ¤æˆæœ¬é«˜ã€åè®®ä¸ä¸€è‡´

#### å®æ–½æ–¹æ¡ˆ

**æ­¥éª¤1: åˆ›å»ºç»Ÿä¸€WebSocketæ¥å£ (2å°æ—¶)**

```typescript
// services/websocket/IWebSocket.ts (æ–°å»º)
export interface IWebSocket {
  // è¿æ¥ç®¡ç†
  connect(url: string, options?: ConnectOptions): Promise<void>;
  disconnect(): Promise<void>;
  isConnected(): boolean;
  getConnectionId(): string;

  // è®¢é˜…ç®¡ç†
  subscribe(channel: string, handler: MessageHandler): void;
  unsubscribe(channel: string): void;
  unsubscribeAll(): void;

  // æ¶ˆæ¯å‘é€
  send(channel: string, message: any): Promise<void>;
  broadcast(channel: string, message: any): Promise<void>;

  // äº‹ä»¶
  on(event: 'connected' | 'disconnected' | 'error', handler: Function): void;
  off(event: string, handler: Function): void;
}

export interface ConnectOptions {
  reconnect?: boolean;
  reconnectInterval?: number;
  maxReconnectAttempts?: number;
  heartbeatInterval?: number;
}

export interface MessageHandler {
  (message: any): void | Promise<void>;
}
```

**æ­¥éª¤2: æœåŠ¡ç«¯å®ç° (2å°æ—¶)**

```typescript
// services/websocket/ServerWebSocket.ts (æ–°å»º)
import { WebSocketServer } from '../../server/websocket/websocketServer';
import { IWebSocket, ConnectOptions } from './IWebSocket';

export class ServerWebSocket implements IWebSocket {
  private wsServer: WebSocketServer;

  constructor(wsServer: WebSocketServer) {
    this.wsServer = wsServer;
  }

  async connect(url: string): Promise<void> {
    // æœåŠ¡ç«¯ä¸éœ€è¦ä¸»åŠ¨è¿æ¥
    throw new Error('Server WebSocket does not support active connection');
  }

  async disconnect(): Promise<void> {
    await this.wsServer.close();
  }

  isConnected(): boolean {
    return this.wsServer.isReady();
  }

  getConnectionId(): string {
    return 'server';
  }

  subscribe(channel: string, handler: MessageHandler): void {
    this.wsServer.on(channel, handler);
  }

  unsubscribe(channel: string): void {
    this.wsServer.off(channel);
  }

  unsubscribeAll(): void {
    this.wsServer.removeAllListeners();
  }

  async send(channel: string, message: any): Promise<void> {
    this.wsServer.broadcast(channel, message);
  }

  async broadcast(channel: string, message: any): Promise<void> {
    this.wsServer.broadcast(channel, message);
  }

  on(event: string, handler: Function): void {
    this.wsServer.on(event, handler);
  }

  off(event: string, handler: Function): void {
    this.wsServer.off(event, handler);
  }
}
```

**æ­¥éª¤3: å®¢æˆ·ç«¯å®ç° (2å°æ—¶)**

```typescript
// services/websocket/ClientWebSocket.ts (æ–°å»º)
import { IWebSocket, ConnectOptions, MessageHandler } from './IWebSocket';

const DEFAULT_OPTIONS: ConnectOptions = {
  reconnect: true,
  reconnectInterval: 3000,
  maxReconnectAttempts: 10,
  heartbeatInterval: 30000
};

export class ClientWebSocket implements IWebSocket {
  private socket: WebSocket | null = null;
  private connectionId: string | null = null;
  private subscriptions: Map<string, Set<MessageHandler>> = new Map();
  private options: ConnectOptions;
  private heartbeatTimer: NodeJS.Timeout | null = null;
  private reconnectAttempts: number = 0;
  private eventHandlers: Map<string, Set<Function>> = new Map();

  constructor(private url: string, options?: ConnectOptions) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
  }

  async connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        this.socket = new WebSocket(this.url);

        this.socket.onopen = () => {
          console.log('[ClientWebSocket] Connected');
          this.connectionId = this.generateConnectionId();
          this.startHeartbeat();
          this.reconnectAttempts = 0;
          this.emit('connected');
          resolve();
        };

        this.socket.onmessage = (event) => {
          this.handleMessage(event.data);
        };

        this.socket.onerror = (error) => {
          console.error('[ClientWebSocket] Error:', error);
          this.emit('error', error);
          reject(error);
        };

        this.socket.onclose = () => {
          console.log('[ClientWebSocket] Disconnected');
          this.stopHeartbeat();
          this.emit('disconnected');

          // è‡ªåŠ¨é‡è¿
          if (this.options.reconnect && this.reconnectAttempts < this.options.maxReconnectAttempts!) {
            this.reconnectAttempts++;
            setTimeout(() => this.connect(), this.options.reconnectInterval);
          }
        };

      } catch (error) {
        reject(error);
      }
    });
  }

  async disconnect(): Promise<void> {
    this.stopHeartbeat();
    if (this.socket) {
      this.socket.close();
      this.socket = null;
    }
  }

  isConnected(): boolean {
    return this.socket?.readyState === WebSocket.OPEN;
  }

  getConnectionId(): string {
    return this.connectionId || '';
  }

  subscribe(channel: string, handler: MessageHandler): void {
    if (!this.subscriptions.has(channel)) {
      this.subscriptions.set(channel, new Set());
    }
    this.subscriptions.get(channel)!.add(handler);

    // å‘é€è®¢é˜…æ¶ˆæ¯
    this.send('/subscribe', { channel });
  }

  unsubscribe(channel: string): void {
    const handlers = this.subscriptions.get(channel);
    if (handlers) {
      handlers.clear();
    }
    this.subscriptions.delete(channel);

    // å‘é€å–æ¶ˆè®¢é˜…æ¶ˆæ¯
    this.send('/unsubscribe', { channel });
  }

  unsubscribeAll(): void {
    this.subscriptions.forEach((handlers, channel) => {
      this.unsubscribe(channel);
    });
  }

  async send(channel: string, message: any): Promise<void> {
    if (!this.isConnected()) {
      throw new Error('WebSocket is not connected');
    }

    this.socket!.send(JSON.stringify({
      channel,
      message,
      timestamp: Date.now()
    }));
  }

  async broadcast(channel: string, message: any): Promise<void> {
    // å®¢æˆ·ç«¯å¹¿æ’­ç­‰åŒäºå‘é€
    await this.send(channel, message);
  }

  on(event: string, handler: Function): void {
    if (!this.eventHandlers.has(event)) {
      this.eventHandlers.set(event, new Set());
    }
    this.eventHandlers.get(event)!.add(handler);
  }

  off(event: string, handler: Function): void {
    const handlers = this.eventHandlers.get(event);
    if (handlers) {
      handlers.delete(handler);
    }
  }

  private handleMessage(data: string): void {
    try {
      const { channel, message } = JSON.parse(data);
      const handlers = this.subscriptions.get(channel);

      if (handlers) {
        handlers.forEach(handler => {
          try {
            handler(message);
          } catch (error) {
            console.error('[ClientWebSocket] Handler error:', error);
          }
        });
      }
    } catch (error) {
      console.error('[ClientWebSocket] Parse error:', error);
    }
  }

  private startHeartbeat(): void {
    this.heartbeatTimer = setInterval(() => {
      if (this.isConnected()) {
        this.send('/heartbeat', {});
      }
    }, this.options.heartbeatInterval);
  }

  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }

  private emit(event: string, data?: any): void {
    const handlers = this.eventHandlers.get(event);
    if (handlers) {
      handlers.forEach(handler => handler(data));
    }
  }

  private generateConnectionId(): string {
    return `client_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

**æ­¥éª¤4: ç»Ÿä¸€ç®¡ç†å™¨ (2å°æ—¶)**

```typescript
// services/websocket/WebSocketService.ts (ä¿®æ”¹)
import { IWebSocket, ConnectOptions } from './IWebSocket';
import { ServerWebSocket } from './ServerWebSocket';
import { ClientWebSocket } from './ClientWebSocket';

export class WebSocketService implements IWebSocket {
  private impl: IWebSocket;

  constructor(environment: 'server' | 'client', url?: string, options?: ConnectOptions) {
    if (environment === 'server') {
      // æœåŠ¡ç«¯å®ç°
      const wsServer = require('../../server/websocket/websocketServer').default;
      this.impl = new ServerWebSocket(wsServer);
    } else {
      // å®¢æˆ·ç«¯å®ç°
      if (!url) {
        throw new Error('URL is required for client WebSocket');
      }
      this.impl = new ClientWebSocket(url, options);
    }
  }

  // å§”æ‰˜æ‰€æœ‰æ–¹æ³•
  async connect(url?: string): Promise<void> {
    if (this.impl instanceof ClientWebSocket && url) {
      return this.impl.connect();
    }
    return this.impl.connect(url!);
  }

  async disconnect(): Promise<void> {
    return this.impl.disconnect();
  }

  isConnected(): boolean {
    return this.impl.isConnected();
  }

  getConnectionId(): string {
    return this.impl.getConnectionId();
  }

  subscribe(channel: string, handler: (message: any) => void): void {
    this.impl.subscribe(channel, handler);
  }

  unsubscribe(channel: string): void {
    this.impl.unsubscribe(channel);
  }

  unsubscribeAll(): void {
    this.impl.unsubscribeAll();
  }

  async send(channel: string, message: any): Promise<void> {
    return this.impl.send(channel, message);
  }

  async broadcast(channel: string, message: any): Promise<void> {
    return this.impl.broadcast(channel, message);
  }

  on(event: string, handler: Function): void {
    this.impl.on(event, handler);
  }

  off(event: string, handler: Function): void {
    this.impl.off(event, handler);
  }
}

// å•ä¾‹å¯¼å‡º
let wsServiceInstance: WebSocketService | null = null;

export function getWebSocketService(environment: 'server' | 'client', url?: string): WebSocketService {
  if (!wsServiceInstance) {
    wsServiceInstance = new WebSocketService(environment, url);
  }
  return wsServiceInstance;
}
```

**æ­¥éª¤5: æ›´æ–°ç°æœ‰ä»£ç  (0.5å°æ—¶)**

```typescript
// services/BatchGenerationScheduler.ts (ä¿®æ”¹)
// ä¿®æ”¹å‰
import { WebSocketManager } from './websocket/websocketManager';

// ä¿®æ”¹å
import { getWebSocketService } from './websocket/WebSocketService';

export class BatchGenerationScheduler {
  private websocket: WebSocketService;

  constructor(/* ... */) {
    // æœåŠ¡ç«¯ç¯å¢ƒ
    this.websocket = getWebSocketService('server');
  }

  // æ–¹æ³•ä¿æŒä¸å˜,å› ä¸ºæ¥å£ä¸€è‡´
}
```

#### éªŒæ”¶æ ‡å‡†

- âœ… ä»£ç é‡å¤å‡å°‘50%+
- âœ… ç»Ÿä¸€çš„APIæ¥å£
- âœ… æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯åè®®ä¸€è‡´
- âœ… æ‰€æœ‰ç°æœ‰åŠŸèƒ½æ­£å¸¸å·¥ä½œ

#### é¢„æœŸæ”¶ç›Š

- **ç»´æŠ¤æˆæœ¬**: é™ä½60%
- **ä»£ç å¤ç”¨ç‡**: æå‡50%+
- **æ–°åŠŸèƒ½å¼€å‘é€Ÿåº¦**: æå‡30%

---

### P0-3: é”™è¯¯å¤„ç†æ ‡å‡†åŒ– â±ï¸ 6å°æ—¶

**é—®é¢˜**: é”™è¯¯å¤„ç†åˆ†æ•£ã€æ ¼å¼ä¸ç»Ÿä¸€ã€ç¼ºå°‘é”™è¯¯åˆ†ç±»

#### å®æ–½æ–¹æ¡ˆ

**æ­¥éª¤1: å»ºç«‹é”™è¯¯ç±»å±‚çº§ (2å°æ—¶)**

```typescript
// types/errors.ts (æ–°å»º)
export abstract class AppError extends Error {
  abstract readonly code: string;
  abstract readonly statusCode: number;
  abstract readonly isOperational: boolean;

  constructor(message: string) {
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }

  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      statusCode: this.statusCode,
      isOperational: this.isOperational
    };
  }
}

// å®¢æˆ·ç«¯é”™è¯¯ (4xx)
export class ValidationError extends AppError {
  readonly code = 'VALIDATION_ERROR';
  readonly statusCode = 400;
  readonly isOperational = true;

  constructor(
    public readonly field: string,
    message: string,
    public readonly value?: any
  ) {
    super(message);
  }
}

export class NotFoundError extends AppError {
  readonly code = 'NOT_FOUND';
  readonly statusCode = 404;
  readonly isOperational = true;

  constructor(public readonly resource: string, public readonly id: string) {
    super(`${resource} with id ${id} not found`);
  }
}

export class UnauthorizedError extends AppError {
  readonly code = 'UNAUTHORIZED';
  readonly statusCode = 401;
  readonly isOperational = true;

  constructor(message: string = 'Authentication required') {
    super(message);
  }
}

export class ForbiddenError extends AppError {
  readonly code = 'FORBIDDEN';
  readonly statusCode = 403;
  readonly isOperational = true;

  constructor(message: string = 'Insufficient permissions') {
    super(message);
  }
}

// æœåŠ¡ç«¯é”™è¯¯ (5xx)
export class InternalServerError extends AppError {
  readonly code = 'INTERNAL_ERROR';
  readonly statusCode = 500;
  readonly isOperational = false;

  constructor(message: string = 'An unexpected error occurred', public readonly cause?: Error) {
    super(message);
  }
}

export class ServiceUnavailableError extends AppError {
  readonly code = 'SERVICE_UNAVAILABLE';
  readonly statusCode = 503;
  readonly isOperational = true;

  constructor(message: string = 'Service temporarily unavailable') {
    super(message);
  }
}

// ç‰¹å®šé¢†åŸŸé”™è¯¯
export class TaskNotFoundError extends NotFoundError {
  constructor(taskId: string) {
    super('Task', taskId);
    this.code = 'TASK_NOT_FOUND';
  }
}

export class TemplateNotFoundError extends NotFoundError {
  constructor(templateId: string) {
    super('Template', templateId);
    this.code = 'TEMPLATE_NOT_FOUND';
  }
}

export class AIServiceError extends InternalServerError {
  readonly code = 'AI_SERVICE_ERROR';
  readonly isOperational = true;

  constructor(message: string, public readonly retryable: boolean = true) {
    super(message);
  }
}
```

**æ­¥éª¤2: é”™è¯¯å¤„ç†ä¸­é—´ä»¶ (2å°æ—¶)**

```typescript
// api/middleware/errorHandler.ts (ä¿®æ”¹)
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../../types/errors';
import logger from '../../utils/logger';

export function errorHandler() {
  return (err: Error, req: Request, res: Response, next: NextFunction) => {
    // è®°å½•å®Œæ•´é”™è¯¯
    logger.error('API Error', {
      error: err.stack,
      request: {
        method: req.method,
        url: req.url,
        headers: sanitizeHeaders(req.headers),
        body: sanitizeBody(req.body)
      }
    });

    // AppErrorå®ä¾‹
    if (err instanceof AppError) {
      return res.status(err.statusCode).json({
        success: false,
        error: {
          code: err.code,
          message: err.message,
          ...(err instanceof ValidationError && {
            field: err.field,
            value: err.value
          }),
          requestId: req.id,
          timestamp: new Date().toISOString()
        }
      });
    }

    // æœªçŸ¥é”™è¯¯
    logger.error('Unhandled error', err);
    return res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
        requestId: req.id,
        timestamp: new Date().toISOString()
      }
    });
  };
}

function sanitizeHeaders(headers: any): any {
  const sanitized = { ...headers };
  delete sanitized.authorization;
  delete sanitized.cookie;
  return sanitized;
}

function sanitizeBody(body: any): any {
  if (!body) return body;

  const sanitized = { ...body };
  const sensitiveFields = ['password', 'token', 'apiKey', 'secret'];

  sensitiveFields.forEach(field => {
    if (sanitized[field]) {
      sanitized[field] = '***';
    }
  });

  return sanitized;
}
```

**æ­¥éª¤3: ç»Ÿä¸€é”™è¯¯å¤„ç†å·¥å…· (1å°æ—¶)**

```typescript
// utils/errorHandler.ts (æ–°å»º)
import { AppError, ValidationError, InternalServerError } from '../types/errors';
import logger from './logger';

export class ErrorHandler {
  private static readonly RETRYABLE_ERRORS = [
    'ECONNRESET',
    'ETIMEDOUT',
    'ENOTFOUND',
    'ECONNREFUSED'
  ];

  static handleError(error: unknown, context?: string): AppError {
    // å·²ç»æ˜¯AppError,ç›´æ¥è¿”å›
    if (error instanceof AppError) {
      return error;
    }

    // æ ‡å‡†Error
    if (error instanceof Error) {
      // ç½‘ç»œé”™è¯¯
      if (this.isNetworkError(error)) {
        return new InternalServerError(
          'Network error, please retry',
          error
        );
      }

      // é»˜è®¤å†…éƒ¨é”™è¯¯
      return new InternalServerError(
        error.message || 'An unexpected error occurred',
        error
      );
    }

    // å…¶ä»–ç±»å‹é”™è¯¯
    return new InternalServerError(
      String(error),
      new Error(String(error))
    );
  }

  static async handleAsync<T>(
    operation: () => Promise<T>,
    context?: string
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      const appError = this.handleError(error, context);
      logger.error(`Async operation failed${context ? `: ${context}` : ''}`, appError);
      throw appError;
    }
  }

  static isRetryable(error: Error): boolean {
    if (error instanceof AppError) {
      // æŸäº›é”™è¯¯å¯ä»¥é‡è¯•
      if (error.code === 'AI_SERVICE_ERROR') {
        return (error as any).retryable;
      }
      return error.isOperational;
    }

    // æ£€æŸ¥é”™è¯¯ç 
    return this.RETRYABLE_ERRORS.some(code =>
      error.message.includes(code)
    );
  }

  private static isNetworkError(error: Error): boolean {
    return this.RETRYABLE_ERRORS.some(code =>
      error.message.includes(code)
    );
  }
}

// ä½¿ç”¨ç¤ºä¾‹è£…é¥°å™¨
export function catchErrors(context?: string) {
  return function (
    target: any,
    propertyName: string,
    descriptor: PropertyDescriptor
  ) {
    const method = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      try {
        return await method.apply(this, args);
      } catch (error) {
        const appError = ErrorHandler.handleError(error, `${target.constructor.name}.${propertyName}`);
        logger.error(`Method failed: ${context || propertyName}`, appError);
        throw appError;
      }
    };

    return descriptor;
  };
}
```

**æ­¥éª¤4: æ›´æ–°æœåŠ¡å±‚é”™è¯¯å¤„ç† (1å°æ—¶)**

```typescript
// services/BatchGenerationScheduler.ts (ä¿®æ”¹)
import { ErrorHandler, catchErrors } from '../utils/errorHandler';
import { TaskNotFoundError, ValidationError } from '../types/errors';

export class BatchGenerationScheduler {
  @catchErrors('createTask')
  async createTask(request: CreateBatchTaskRequest): Promise<CreateBatchTaskResponse> {
    // éªŒè¯
    if (!request.templateIds || request.templateIds.length === 0) {
      throw new ValidationError(
        'templateIds',
        'At least one templateId is required',
        request.templateIds
      );
    }

    // ä¸šåŠ¡é€»è¾‘
    const templates = await ErrorHandler.handleAsync(
      () => this.validateTemplates(request.templateIds),
      'validateTemplates'
    );

    // ...
  }

  async getTask(taskId: string): Promise<BatchGenerationTask> {
    const task = this.tasks.get(taskId);

    if (!task) {
      throw new TaskNotFoundError(taskId);
    }

    return task;
  }
}
```

#### éªŒæ”¶æ ‡å‡†

- âœ… æ‰€æœ‰é”™è¯¯ç»Ÿä¸€æ ¼å¼
- âœ… é”™è¯¯ä¿¡æ¯æ¸…æ™°ã€ç”¨æˆ·å‹å¥½
- âœ… æ•æ„Ÿä¿¡æ¯ä¸æ³„éœ²
- âœ… å‰ç«¯å¯ç»Ÿä¸€å¤„ç†é”™è¯¯

#### é¢„æœŸæ”¶ç›Š

- **é”™è¯¯å¤„ç†ä¸€è‡´æ€§**: æå‡90%
- **è°ƒè¯•æ•ˆç‡**: æå‡50%
- **ç”¨æˆ·ä½“éªŒ**: æ˜¾è‘—æ”¹å–„

---

### P0-4: å†…å­˜æ³„æ¼ä¿®å¤ â±ï¸ 8å°æ—¶

**é—®é¢˜**: å¤§æ•°æ®é›†å¤„ç†å¯èƒ½å¯¼è‡´å†…å­˜æº¢å‡º

#### å®æ–½æ–¹æ¡ˆ

**æ­¥éª¤1: æµå¼æ•°æ®å¤„ç† (4å°æ—¶)**

```typescript
// services/ai/dataQualityAnalyzer.ts (ä¿®æ”¹)
export class DataQualityAnalyzer {
  private readonly MAX_BATCH_SIZE = 10000;
  private readonly MAX_MEMORY_USAGE = 500 * 1024 * 1024; // 500MB

  async *analyzeStreaming(
    data: ExcelData,
    options?: AnalysisOptions
  ): AsyncGenerator<DataQualityReport, void, unknown> {
    const sheetData = this.extractSheetData(data);
    const totalRows = sheetData.length;

    logger.info(`Starting streaming analysis for ${totalRows} rows`);

    // åˆ†æ‰¹å¤„ç†
    for (let i = 0; i < totalRows; i += this.MAX_BATCH_SIZE) {
      // æ£€æŸ¥å†…å­˜ä½¿ç”¨
      const memoryUsage = process.memoryUsage().heapUsed;
      if (memoryUsage > this.MAX_MEMORY_USAGE) {
        logger.warn(`Memory usage high: ${memoryUsage} bytes, forcing GC`);
        await this.forceGarbageCollection();
      }

      const batch = sheetData.slice(i, Math.min(i + this.MAX_BATCH_SIZE, totalRows));

      logger.debug(`Processing batch ${Math.floor(i / this.MAX_BATCH_SIZE) + 1}, size: ${batch.length}`);

      // å¤„ç†å½“å‰æ‰¹æ¬¡
      const result = await this.processBatch(batch, options);

      yield result;

      // é‡Šæ”¾å†…å­˜
      await this.releaseMemory();
    }
  }

  private async processBatch(
    batch: any[],
    options?: AnalysisOptions
  ): Promise<DataQualityReport> {
    // æ‰¹æ¬¡å¤„ç†é€»è¾‘
    const columnStats = await this.generateColumnStats(batch);
    const detectionResults = await this.runDetectors(batch, columnStats, options);

    return {
      summary: this.generateSummary(batch, detectionResults),
      columns: columnStats,
      issues: detectionResults
    };
  }

  private async forceGarbageCollection(): Promise<void> {
    if (global.gc) {
      return new Promise(resolve => {
        global.gc();
        setTimeout(resolve, 100); // ç­‰å¾…GCå®Œæˆ
      });
    }
  }

  private async releaseMemory(): Promise<void> {
    // æ¸…ç†ç¼“å­˜
    this.clearCache();

    // å¼ºåˆ¶GC
    await this.forceGarbageCollection();
  }

  private clearCache(): void {
    // æ¸…ç†å†…éƒ¨ç¼“å­˜
    this.columnStatsCache?.clear();
    this.detectorCache?.clear();
  }
}
```

**æ­¥éª¤2: WebSocketè¿æ¥æ¸…ç† (2å°æ—¶)**

```typescript
// server/websocket/websocketServer.ts (ä¿®æ”¹)
export class WebSocketServer extends EventEmitter {
  private cleanupTimer: NodeJS.Timeout | null = null;

  constructor(options: WebSocketServerOptions) {
    super(options);
    this.startCleanupTimer();
  }

  private startCleanupTimer(): void {
    // æ¯5åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡æ–­å¼€çš„è¿æ¥
    this.cleanupTimer = setInterval(() => {
      this.cleanupDisconnectedClients();
    }, 5 * 60 * 1000);
  }

  private cleanupDisconnectedClients(): void {
    const before = this.clients.size;

    // ç§»é™¤å·²æ–­å¼€çš„å®¢æˆ·ç«¯
    for (const [clientId, client] of this.clients.entries()) {
      if (client.socket.readyState === WebSocket.CLOSED) {
        this.clients.delete(clientId);
        logger.info(`Cleaned up disconnected client: ${clientId}`);
      }
    }

    const after = this.clients.size;
    if (before !== after) {
      logger.info(`Cleanup completed: removed ${before - after} disconnected clients`);
    }
  }

  close(): void {
    // æ¸…ç†å®šæ—¶å™¨
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = null;
    }

    // å…³é—­æ‰€æœ‰è¿æ¥
    this.clients.forEach((client) => {
      if (client.socket.readyState === WebSocket.OPEN) {
        client.socket.close();
      }
    });
    this.clients.clear();

    super.close();
  }
}
```

**æ­¥éª¤3: ç¼“å­˜ç­–ç•¥ä¼˜åŒ– (2å°æ—¶)**

```typescript
// services/cache/MemoryCacheService.ts (ä¿®æ”¹)
export class MemoryCacheService implements IStorageService {
  private cache: Map<string, { value: any; expires: number }>;
  private maxEntries: number;
  private maxMemory: number;
  private cleanupTimer: NodeJS.Timeout;

  constructor(options: { maxEntries?: number; maxMemory?: number } = {}) {
    this.cache = new Map();
    this.maxEntries = options.maxEntries || 1000;
    this.maxMemory = options.maxMemory || 100 * 1024 * 1024; // 100MB

    // å®šæœŸæ¸…ç†è¿‡æœŸæ¡ç›®
    this.cleanupTimer = setInterval(() => {
      this.cleanup();
    }, 60 * 1000);
  }

  async set(key: string, value: any, ttl?: number): Promise<void> {
    // æ£€æŸ¥ç¼“å­˜å¤§å°
    if (this.cache.size >= this.maxEntries) {
      this.evictLRU();
    }

    // æ£€æŸ¥å†…å­˜ä½¿ç”¨
    const memoryUsage = this.estimateMemoryUsage();
    if (memoryUsage > this.maxMemory) {
      this.evictLRU();
    }

    const expires = ttl ? Date.now() + ttl * 1000 : Number.MAX_SAFE_INTEGER;
    this.cache.set(key, { value, expires, lastAccess: Date.now() });
  }

  private cleanup(): void {
    const now = Date.now();
    const before = this.cache.size;

    // ç§»é™¤è¿‡æœŸæ¡ç›®
    for (const [key, item] of this.cache.entries()) {
      if (item.expires < now) {
        this.cache.delete(key);
      }
    }

    const after = this.cache.size;
    if (before !== after) {
      logger.debug(`Cache cleanup: removed ${before - after} expired entries`);
    }
  }

  private evictLRU(): void {
    // æ‰¾åˆ°æœ€å°‘ä½¿ç”¨çš„æ¡ç›®
    let oldestKey: string | null = null;
    let oldestTime = Date.now();

    for (const [key, item] of this.cache.entries()) {
      if (item.lastAccess < oldestTime) {
        oldestTime = item.lastAccess;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey);
      logger.debug(`Evicted LRU cache entry: ${oldestKey}`);
    }
  }

  private estimateMemoryUsage(): number {
    // ç²—ç•¥ä¼°è®¡
    let size = 0;
    for (const [, item] of this.cache.entries()) {
      size += JSON.stringify(item.value).length * 2; // UTF-16
    }
    return size;
  }

  destroy(): void {
    clearInterval(this.cleanupTimer);
    this.cache.clear();
  }
}
```

#### éªŒæ”¶æ ‡å‡†

- âœ… å¤„ç†100MB+æ–‡ä»¶ä¸å´©æºƒ
- âœ… å†…å­˜ä½¿ç”¨ç¨³å®šåœ¨500MBä»¥å†…
- âœ… WebSocketè¿æ¥æ­£å¸¸æ¸…ç†
- âœ… ç¼“å­˜è‡ªåŠ¨æ¸…ç†è¿‡æœŸæ•°æ®

#### é¢„æœŸæ”¶ç›Š

- **ç¨³å®šæ€§**: æ˜¾è‘—æå‡
- **å†…å­˜ä½¿ç”¨**: é™ä½40%
- **å¤§æ–‡ä»¶å¤„ç†**: èƒ½åŠ›æå‡10å€+

---

## ç¬¬äºŒéƒ¨åˆ†: P1çº§åˆ«ä¼˜åŒ– (Week 2)

### P1-1: çŠ¶æ€ç®¡ç†ä¼˜åŒ– â±ï¸ 12å°æ—¶

**é—®é¢˜**: çŠ¶æ€åˆ†æ•£åœ¨ç»„ä»¶ã€æœåŠ¡ã€WebSocketå„å¤„

#### å®æ–½æ–¹æ¡ˆ

**ä½¿ç”¨Zustand + React Query**

```typescript
// stores/taskStore.ts (æ–°å»º)
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

interface TaskState {
  // çŠ¶æ€
  tasks: Map<string, Task>;
  activeTaskId: string | null;
  filters: TaskFilters;

  // æ“ä½œ
  setActiveTask: (id: string) => void;
  updateTask: (id: string, updates: Partial<Task>) => void;
  addTask: (task: Task) => void;
  removeTask: (id: string) => void;
  setFilters: (filters: TaskFilters) => void;

  // WebSocketåŒæ­¥
  syncFromWebSocket: (event: TaskEvent) => void;
}

export const useTaskStore = create<TaskState>()(
  devtools(
    persist(
      (set, get) => ({
        tasks: new Map(),
        activeTaskId: null,
        filters: { status: 'all' },

        setActiveTask: (id) => set({ activeTaskId: id }),

        updateTask: (id, updates) => set((state) => {
          const tasks = new Map(state.tasks);
          const existing = tasks.get(id);
          if (existing) {
            tasks.set(id, { ...existing, ...updates });
          }
          return { tasks };
        }),

        addTask: (task) => set((state) => {
          const tasks = new Map(state.tasks);
          tasks.set(task.id, task);
          return { tasks };
        }),

        removeTask: (id) => set((state) => {
          const tasks = new Map(state.tasks);
          tasks.delete(id);
          return { tasks };
        }),

        setFilters: (filters) => set({ filters }),

        syncFromWebSocket: (event) => set((state) => {
          const tasks = new Map(state.tasks);

          switch (event.type) {
            case 'task:created':
              tasks.set(event.task.id, event.task);
              break;
            case 'task:updated':
              tasks.set(event.taskId, {
                ...tasks.get(event.taskId),
                ...event.updates
              });
              break;
            case 'task:deleted':
              tasks.delete(event.taskId);
              break;
          }

          return { tasks };
        })
      }),
      {
        name: 'task-storage',
        partialize: (state) => ({
          tasks: Array.from(state.tasks.entries()),
          activeTaskId: state.activeTaskId
        })
      }
    )
  )
);
```

#### éªŒæ”¶æ ‡å‡†

- âœ… çŠ¶æ€ä¸€è‡´æ€§æå‡90%
- âœ… ç»„ä»¶é‡æ¸²æŸ“å‡å°‘60%
- âœ… WebSocketçŠ¶æ€è‡ªåŠ¨åŒæ­¥

#### é¢„æœŸæ”¶ç›Š

- **ç”¨æˆ·ä½“éªŒ**: æ˜¾è‘—æå‡
- **ä»£ç å¯ç»´æŠ¤æ€§**: æå‡50%
- **Bugæ•°é‡**: å‡å°‘70%

---

### P1-2: ç›‘æ§ä½“ç³»å®Œå–„ â±ï¸ 16å°æ—¶

**é—®é¢˜**: ç›‘æ§è¦†ç›–ä¸å…¨,ç¼ºå°‘ä¸šåŠ¡æŒ‡æ ‡

#### å®æ–½æ–¹æ¡ˆ

**é›†æˆPrometheus + Grafana**

è¯¦ç»†ä»£ç è§`BACKEND_ARCHITECTURE_ANALYSIS.md`çš„ä¼˜åŒ–5ã€‚

#### éªŒæ”¶æ ‡å‡†

- âœ… APIå“åº”æ—¶é—´ç›‘æ§
- âœ… é”™è¯¯ç‡ç»Ÿè®¡
- âœ… ä¸šåŠ¡æŒ‡æ ‡è¿½è¸ª
- âœ… å‘Šè­¦æœºåˆ¶

#### é¢„æœŸæ”¶ç›Š

- **é—®é¢˜å‘ç°é€Ÿåº¦**: æå‡80%
- **è¿ç»´æ•ˆç‡**: æå‡60%

---

### P1-3: ä¾èµ–æ³¨å…¥å¼•å…¥ â±ï¸ 12å°æ—¶

**é—®é¢˜**: ç»„ä»¶è€¦åˆåº¦é«˜,éš¾ä»¥æµ‹è¯•

#### å®æ–½æ–¹æ¡ˆ

**ä½¿ç”¨InversifyJS**

è¯¦ç»†ä»£ç è§`BACKEND_ARCHITECTURE_ANALYSIS.md`çš„ä¼˜åŒ–1ã€‚

#### éªŒæ”¶æ ‡å‡†

- âœ… æ‰€æœ‰æœåŠ¡é€šè¿‡å®¹å™¨ç®¡ç†
- âœ… å•å…ƒæµ‹è¯•å¯è½»æ¾Mockä¾èµ–
- âœ… é…ç½®é›†ä¸­ç®¡ç†

#### é¢„æœŸæ”¶ç›Š

- **ä»£ç å¯æµ‹è¯•æ€§**: æå‡80%
- **ç»´æŠ¤æˆæœ¬**: é™ä½40%

---

### P1-4: APIè®¤è¯æˆæƒ â±ï¸ 16å°æ—¶

**é—®é¢˜**: æ— èº«ä»½éªŒè¯å’Œæƒé™æ§åˆ¶

#### å®æ–½æ–¹æ¡ˆ

**JWT + RBAC**

è¯¦ç»†ä»£ç è§`BACKEND_ARCHITECTURE_ANALYSIS.md`çš„ä¼˜åŒ–6ã€‚

#### éªŒæ”¶æ ‡å‡†

- âœ… JWTè®¤è¯æ­£å¸¸å·¥ä½œ
- âœ… RBACæƒé™æ§åˆ¶ç”Ÿæ•ˆ
- âœ… æ‰€æœ‰APIç«¯ç‚¹å—ä¿æŠ¤

#### é¢„æœŸæ”¶ç›Š

- **å®‰å…¨æ€§**: æå‡100%
- **å¤šç§Ÿæˆ·æ”¯æŒ**: å¯å®ç°

---

## ç¬¬ä¸‰éƒ¨åˆ†: æ‰§è¡Œè®¡åˆ’

### Week 1: Day 4-7 (P0ä¼˜åŒ–)

| æ—¥æœŸ | ä»»åŠ¡ | è´Ÿè´£äºº | å·¥æ—¶ |
|------|------|--------|------|
| Day 4 | APIå¯†é’¥å®‰å…¨åŠ å›º | Backend Dev | 4h |
| Day 5 | WebSocketå®ç°ç»Ÿä¸€ | Backend Lead | 8h |
| Day 6 | é”™è¯¯å¤„ç†æ ‡å‡†åŒ– | Backend Dev | 6h |
| Day 7 | å†…å­˜æ³„æ¼ä¿®å¤ + éªŒæ”¶ | Backend Team | 8h |

### Week 2: Day 8-14 (P1ä¼˜åŒ–)

| æ—¥æœŸ | ä»»åŠ¡ | è´Ÿè´£äºº | å·¥æ—¶ |
|------|------|--------|------|
| Day 8-10 | çŠ¶æ€ç®¡ç†ä¼˜åŒ– | Frontend Dev | 12h |
| Day 10-14 | ç›‘æ§ä½“ç³»å®Œå–„ | DevOps + Backend | 16h |
| Day 11-14 | ä¾èµ–æ³¨å…¥å¼•å…¥ | Backend Lead | 12h |
| Day 11-14 | APIè®¤è¯æˆæƒ | Backend Dev | 16h |

---

## ç¬¬å››éƒ¨åˆ†: æˆåŠŸæŒ‡æ ‡

### æŠ€æœ¯æŒ‡æ ‡

| æŒ‡æ ‡ | å½“å‰ | ç›®æ ‡ | æµ‹é‡æ–¹å¼ |
|------|------|------|----------|
| APIå“åº”æ—¶é—´(P95) | ~5ms | <500ms | APMç›‘æ§ |
| å†…å­˜ä½¿ç”¨ | ä¸ç¨³å®š | <500MB | Chrome DevTools |
| é”™è¯¯ç‡ | æœªçŸ¥ | <0.1% | Sentryç»Ÿè®¡ |
| æµ‹è¯•è¦†ç›–ç‡ | 95% | >90% | JestæŠ¥å‘Š |

### è´¨é‡æŒ‡æ ‡

| æŒ‡æ ‡ | å½“å‰ | ç›®æ ‡ | æµ‹é‡æ–¹å¼ |
|------|------|------|----------|
| P0/P1 Bugæ•° | æœªçŸ¥ | 0 | Bugè¿½è¸ª |
| ä»£ç é‡å¤ç‡ | é«˜ | <5% | SonarQube |
| æŠ€æœ¯å€ºåŠ¡æŒ‡æ•° | æœªçŸ¥ | <5% | SonarQube |

---

## ç¬¬äº”éƒ¨åˆ†: é£é™©ä¸ç¼“è§£

| é£é™© | æ¦‚ç‡ | å½±å“ | ç¼“è§£æªæ–½ |
|------|------|------|----------|
| ä¼˜åŒ–å¼•å…¥æ–°Bug | ä¸­ | é«˜ | å……åˆ†æµ‹è¯•ã€ç°åº¦å‘å¸ƒ |
| æ€§èƒ½å›é€€ | ä½ | ä¸­ | æ€§èƒ½åŸºå‡†æµ‹è¯• |
| å»¶æœŸé£é™© | ä½ | ä¸­ | ç¼“å†²æ—¶é—´é¢„ç•™ |

---

## é™„å½•

### A. ç›¸å…³æ–‡æ¡£

- `FULLSTACK_INTEGRATION_ANALYSIS.md` - å…¨æ ˆé›†æˆåˆ†æ
- `BACKEND_ARCHITECTURE_ANALYSIS.md` - åç«¯æ¶æ„åˆ†æ
- `CTO_STRATEGIC_ASSESSMENT_2026.md` - CTOæˆ˜ç•¥è¯„ä¼°
- `Sprint1_Day1-3_å®Œæˆæ€»ç»“æŠ¥å‘Š.md` - Sprint 1æ€»ç»“

### B. æŠ€æœ¯é€‰å‹

| é¢†åŸŸ | æŠ€æœ¯é€‰å‹ | ç†ç”± |
|------|---------|------|
| çŠ¶æ€ç®¡ç† | Zustand + React Query | è½»é‡ã€ç±»å‹å®‰å…¨ |
| ç›‘æ§ | Prometheus + Grafana | è¡Œä¸šæ ‡å‡† |
| ä¾èµ–æ³¨å…¥ | InversifyJS | TypeScriptå‹å¥½ |
| è®¤è¯ | JWT + Passport | æˆç†Ÿæ–¹æ¡ˆ |

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ¶å®šäºº**: AIæŠ€æœ¯å›¢é˜Ÿ
**æ‰¹å‡†äºº**: CTO
**æ‰§è¡Œå¼€å§‹**: 2026-01-25
**é¢„è®¡å®Œæˆ**: 2026-02-08
