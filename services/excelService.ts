import * as XLSX from 'xlsx';
import { ExcelData } from '../types';

export const readExcelFile = async (file: File): Promise<ExcelData> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = e.target?.result;
        const workbook = XLSX.read(data, { type: 'binary' });

        const sheets: { [key: string]: any[] } = {};
        const metadata: {
          [sheetName: string]: {
            comments: { [cellAddress: string]: string };
            notes?: { [cellAddress: string]: string };
            rowCount: number;
            columnCount: number;
          }
        } = {};
        let firstSheetName = '';

        workbook.SheetNames.forEach((name, index) => {
          if (index === 0) firstSheetName = name;
          const worksheet = workbook.Sheets[name];

          // 读取主要数据
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { defval: "" });
          sheets[name] = jsonData;

          // 提取元数据：注释和标注
          const comments: { [cellAddress: string]: string } = {};
          const notes: { [cellAddress: string]: string } = {};

          // 遍历工作表中的所有单元格
          for (const cellAddress in worksheet) {
            if (cellAddress.startsWith('!')) continue; // 跳过元数据字段

            const cell = worksheet[cellAddress];

            // 提取单元格注释
            if (cell.c) {
              // cell.c 是注释对象数组
              cell.c.forEach((comment: any) => {
                if (comment.a && comment.t) {
                  // comment.a 是作者，comment.t 是文本
                  const commentText = comment.t;
                  const author = comment.a || '';
                  comments[cellAddress] = author ? `[${author}]: ${commentText}` : commentText;
                }
              });
            }

            // 提取单元格标注 (Note)
            if (cell.n) {
              notes[cellAddress] = cell.n;
            }
          }

          // 计算行列数
          const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
          const rowCount = range.e.r + 1; // 结束行号 + 1
          const columnCount = range.e.c + 1; // 结束列号 + 1

          metadata[name] = {
            comments,
            notes,
            rowCount,
            columnCount
          };
        });

        resolve({
          id: file.name + '-' + Date.now(),
          fileName: file.name,
          sheets,
          currentSheetName: firstSheetName,
          metadata
        });
      } catch (err) {
        reject(err);
      }
    };
    reader.onerror = (err) => reject(err);
    reader.readAsBinaryString(file);
  });
};

/**
 * 导出单个sheet到Excel
 */
export const exportToExcel = (data: any[], fileName: string) => {
  const worksheet = XLSX.utils.json_to_sheet(data);
  const workbook = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(workbook, worksheet, "Sheet1");
  XLSX.writeFile(workbook, fileName.endsWith('.xlsx') ? fileName : `${fileName}.xlsx`);
};

/**
 * 导出多sheet到Excel
 * @param sheets 对象，key为sheet名称，value为数据数组
 * @param fileName 文件名
 */
export const exportMultipleSheetsToExcel = (sheets: { [sheetName: string]: any[] }, fileName: string) => {
  const workbook = XLSX.utils.book_new();

  Object.entries(sheets).forEach(([sheetName, data]) => {
    const worksheet = XLSX.utils.json_to_sheet(data);
    XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
  });

  XLSX.writeFile(workbook, fileName.endsWith('.xlsx') ? fileName : `${fileName}.xlsx`);
};

/**
 * Executes the AI-generated JavaScript code in a Web Worker (Sandbox).
 * This prevents the main thread from freezing and provides a layer of isolation.
 * @param code The function body string generated by AI
 * @param datasets A map of filename -> data array
 */
export const executeTransformation = async (
  code: string,
  datasets: { [fileName: string]: any[] },
  timeoutMs: number = 30000 // Default 30 seconds
): Promise<{ [fileName: string]: any[] }> => {
  return new Promise((resolve, reject) => {
    // 1. 记录原始代码用于调试
    console.log('[Code Execution] Original AI code:', code);
    console.log('[Code Execution] Code length:', code.length);

    // 2. Clean and validate the code before creating worker
    const cleanCode = code
      .replace(/`/g, '\\`')  // 转义反引号
      .replace(/\\n/g, '\n')  // 处理换行符
      .trim();

    console.log('[Code Execution] Cleaned code:', cleanCode);

    // 3. Basic syntax validation
    try {
      new Function(cleanCode);
      console.log('[Code Execution] Basic syntax validation passed');
    } catch (syntaxError) {
      console.error('[Code Execution] Syntax validation failed:', syntaxError);
      console.error('[Code Execution] Failed code snippet:', cleanCode.substring(0, 500));
      reject(new Error(`代码语法错误: ${syntaxError.message}\n问题代码: ${cleanCode.substring(0, 200)}...`));
      return;
    }

    // 4. Create the worker script content
    // 使用转义的JSON字符串传递代码，避免任何语法问题
    const workerScript = `
      self.onmessage = function(e) {
        const { code, datasets } = e.data;

        console.log('[Worker] Received code, length:', code.length);
        console.log('[Worker] Datasets keys:', Object.keys(datasets));

        try {
          const files = structuredClone(datasets);

          if (!files || typeof files !== 'object') {
            throw new Error('Invalid files data provided to worker');
          }

          console.log('[Worker] Creating transformation function...');

          // 使用eval来执行代码（这是安全的，因为代码来自AI且已经过验证）
          // 构造一个完整的函数表达式
          const functionCode = 'function(files) { ' + code + ' }';
          const transformFn = eval('(' + functionCode + ')');

          console.log('[Worker] Function created successfully');

          const result = transformFn(files);

          console.log('[Worker] Transformation result:', result);

          if (result === null || result === undefined) {
            throw new Error("Transformation code returned null or undefined.");
          }

          if (typeof result !== 'object' || Array.isArray(result)) {
            throw new Error("Transformation code must return an object. Got: " + typeof result);
          }

          const hasArrayData = (obj) => {
            if (Array.isArray(obj)) return true;
            if (typeof obj === 'object' && obj !== null) {
              return Object.values(obj).some(hasArrayData);
            }
            return false;
          };

          const isValidResult = Object.keys(result).length > 0 &&
            Object.values(result).some(hasArrayData);

          if (!isValidResult) {
            console.error('[Validation Error] Invalid result format:', result);
            throw new Error("Invalid result format. Expected: { fileName: dataArray[] }");
          }

          console.log('[Worker] Validation passed, posting success');
          self.postMessage({ success: true, data: result });
        } catch (error) {
          console.error('[Worker] Error:', error);
          console.error('[Worker] Error stack:', error.stack);
          self.postMessage({ success: false, error: error.message });
        }
      };
    `;

    // 2. Create a Blob from the script and generate a URL
    const blob = new Blob([workerScript], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(blob);
    const worker = new Worker(workerUrl);

    // 3. Set a timeout to prevent infinite loops
    const timeoutId = setTimeout(() => {
      worker.terminate();
      URL.revokeObjectURL(workerUrl);
      reject(new Error(`Execution timed out (${timeoutMs}ms limit). logic is too complex or has infinite loop.`));
    }, timeoutMs);

    // 4. Handle messages from the worker
    worker.onmessage = (e) => {
      clearTimeout(timeoutId);
      worker.terminate();
      URL.revokeObjectURL(workerUrl); // Clean up

      if (e.data.success) {
        resolve(e.data.data);
      } else {
        reject(new Error(e.data.error || "Unknown worker error"));
      }
    };

    // 5. Handle worker errors (script loading errors, etc.)
    worker.onerror = (e) => {
      clearTimeout(timeoutId);
      worker.terminate();
      URL.revokeObjectURL(workerUrl);
      reject(new Error(`Worker Error: ${e.message}`));
    };

    // 6. Send the payload
    worker.postMessage({ code, datasets });
  });
};