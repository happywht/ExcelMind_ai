import * as XLSX from 'xlsx';
import { ExcelData } from '../types';

export const readExcelFile = async (file: File): Promise<ExcelData> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = e.target?.result;
        const workbook = XLSX.read(data, { type: 'array' });

        const sheets: { [sheetName: string]: any[] } = {};
        const metadata: { [sheetName: string]: any } = {};
        let firstSheetName = '';

        workbook.SheetNames.forEach((name, index) => {
          if (index === 0) firstSheetName = name;
          const worksheet = workbook.Sheets[name];

          // Read main table data
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { defval: "" });
          sheets[name] = jsonData;

          // Extract metadata: comments and notes
          const comments: { [cellAddress: string]: string } = {};
          const notes: { [cellAddress: string]: string } = {};

          // Iterate all cells in the sheet
          for (const cellAddress in worksheet) {
            if (cellAddress.startsWith('!')) continue; // Skip metadata fields

            const cell = worksheet[cellAddress];

            // Extract cell comments (c)
            if (cell.c) {
              cell.c.forEach((comment: any) => {
                if (comment.a && comment.t) {
                  const commentText = comment.t;
                  const author = comment.a || '';
                  comments[cellAddress] = author ? `[${author}]: ${commentText}` : commentText;
                }
              });
            }

            // Extract cell notes/annotations (n) - some versions use this
            if (cell.n) {
              notes[cellAddress] = cell.n;
            }
          }

          // Calculate dimensions
          const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');

          metadata[name] = {
            comments,
            notes,
            rowCount: range.e.r + 1,
            columnCount: range.e.c + 1
          };
        });

        resolve({
          id: file.name + '-' + Date.now(),
          fileName: file.name,
          sheets,
          currentSheetName: firstSheetName,
          metadata
        });
      } catch (err) {
        reject(err);
      }
    };
    reader.onerror = (err) => reject(err);
    reader.readAsArrayBuffer(file);
  });
};

export const exportMultipleSheetsToExcel = (sheets: { [sheetName: string]: any[] }, fileName: string) => {
  const workbook = XLSX.utils.book_new();

  Object.entries(sheets).forEach(([sheetName, data]) => {
    const worksheet = XLSX.utils.json_to_sheet(data);
    XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
  });

  XLSX.writeFile(workbook, fileName.endsWith('.xlsx') ? fileName : `${fileName}.xlsx`);
};

export const exportToExcel = (data: any[], fileName: string) => {
  const worksheet = XLSX.utils.json_to_sheet(data);
  const workbook = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(workbook, worksheet, "Sheet1");
  XLSX.writeFile(workbook, fileName.endsWith('.xlsx') ? fileName : `${fileName}.xlsx`);
};

/**
 * Executes the AI-generated JavaScript code in a Web Worker (Sandbox).
 * This prevents the main thread from freezing and provides a layer of isolation.
 * @param code The function body string generated by AI
 * @param datasets A map of filename -> data array
 */
export const executeTransformation = async (
  code: string,
  datasets: { [fileName: string]: any[] }
): Promise<{ [fileName: string]: any[] }> => {
  return new Promise((resolve, reject) => {
    // 1. Create the worker script content
    const workerScript = `
      self.onmessage = function(e) {
        const { code, datasets } = e.data;
        try {
          // Deep clone the data to simulate a fresh environment and prevent reference leaks
          // structuredClone is available in modern browsers/workers
          const files = structuredClone(datasets);

          // Wrap the user's code in a function with better error handling
          // The code is expected to be a function body that manipulates 'files' and returns it.
          const transformFn = new Function('files', \`
            try {
              ${code}
              // 确保始终返回files对象
              return files || {};
            } catch (e) {
              throw new Error('Code execution error: ' + e.message);
            }
          \`);

          const result = transformFn(files);

          // 更严格的返回值检查
          if (result === null || result === undefined) {
            throw new Error("Transformation code returned null or undefined. Expected to return a files object.");
          }

          if (typeof result !== 'object' || Array.isArray(result)) {
            throw new Error("Transformation code must return an object with file data. Got: " + typeof result);
          }

          // 验证返回的对象结构
          const isValidResult = Object.keys(result).length > 0 &&
            Object.values(result).every(arr => Array.isArray(arr));

          if (!isValidResult) {
            throw new Error("Invalid result format. Expected: { fileName: dataArray[] }");
          }

          self.postMessage({ success: true, data: result });
        } catch (error) {
          self.postMessage({ success: false, error: error.message });
        }
      };
    `;

    // 2. Create a Blob from the script and generate a URL
    const blob = new Blob([workerScript], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(blob);
    const worker = new Worker(workerUrl);

    // 3. Set a timeout to prevent infinite loops (e.g., 30 seconds)
    const timeoutId = setTimeout(() => {
      worker.terminate();
      URL.revokeObjectURL(workerUrl);
      reject(new Error("Execution timed out (30s limit). logic is too complex or has infinite loop."));
    }, 30000);

    // 4. Handle messages from the worker
    worker.onmessage = (e) => {
      clearTimeout(timeoutId);
      worker.terminate();
      URL.revokeObjectURL(workerUrl); // Clean up

      if (e.data.success) {
        resolve(e.data.data);
      } else {
        reject(new Error(e.data.error || "Unknown worker error"));
      }
    };

    // 5. Handle worker errors (script loading errors, etc.)
    worker.onerror = (e) => {
      clearTimeout(timeoutId);
      worker.terminate();
      URL.revokeObjectURL(workerUrl);
      reject(new Error(`Worker Error: ${e.message}`));
    };

    // 6. Send the payload
    worker.postMessage({ code, datasets });
  });
};